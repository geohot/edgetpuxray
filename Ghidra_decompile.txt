I spent some time looking at the decompiled edgetpu_compiler.
I saw a few refenreces to llvm in there, specificaly to llvm::mlir, so i went looking on the web for that library.
Found it here https://github.com/llvm/llvm-project/tree/main/mlir/lib
It seams like the people who built the edgetpu compiler used the mlir lib.
I started comparing strings in the source and from that I managed to identify some of the functions.
With the class definitions from the llvm project and some correctly placed breakpoints,
one should be able to figurue out what ops are defined and more.

The most interesting function that i managed to identify that i think would benefit from some breakpoints is(located at 0x00839dc0 in Ghidra):
RegisteredOperationName::insert(
    StringRef name, Dialect &dialect, TypeID typeID,
    ParseAssemblyFn &&parseAssembly, PrintAssemblyFn &&printAssembly,
    VerifyInvariantsFn &&verifyInvariants,
    VerifyRegionInvariantsFn &&verifyRegionInvariants, FoldHookFn &&foldHook,
    GetCanonicalizationPatternsFn &&getCanonicalizationPatterns,
    detail::InterfaceMap &&interfaceMap, HasTraitFn &&hasTrait,
    ArrayRef<StringRef> attrNames,
    PopulateDefaultAttrsFn &&populateDefaultAttrs)
  

Since most functions seam to come more or less in the order that they where writen in the .cpp files
it should be quite easy to identify the functions that are inbetwen the already indentified functions.

Download the Ghidra project zip file here: (Press file -> import file) to import to project
https://drive.google.com/file/d/1JAHxwpnjEb6t31JE8Jkw0mSkAHJD4547/view?usp=sharing

A good next step would probably be to build the llvm mlir project with symbols, then import those symbols in to ghidra so that Ghidra can decode all the structs and classes that get passed in to the functions. For example the RegisteredOperationName::insert function returns a mlir::Operation class witch has varius intresting properties.

A note on that, is that back when i did string matching of the binary and the source file, there was strings that should have been in the binary based on what i saw in the source that where not. I asume the difference was due to the fact that llvm mlir library that is used in the binary is not the latest version. It would be good to identify which version of the mlir library is used in the binary.

A new note..
Found a string in the binary that indicates build info.
"Chromium OS 10.0_pre380035_p20200212-r9 clang version 10.0.0 (/var/cache/chromeos-cache/distfiles/host/egit-src/llvm-project a21beccea2020f950845cbb68db663d0737e174c)"

That version of llvm can be downloaded here:
github.com/llvm/llvm-project/archive/a21beccea2020f950845cbb68db663d0737e174c.tar.gz

But that seams to be the llvm version that was used to compile the compiler itself, not the version of llvm that it links to.

There is also this string with build info "gcc-4.X.Y-crosstool-v18-x86_64-linux-gnu-libcxx-glibc" 

The binary was realesed 8 Jul 2020 this means that the highest llvm version they could have used was llvm LLVM 10.0.1-rc2 which was released at 26 Jun 2020.
